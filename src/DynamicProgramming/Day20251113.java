package DynamicProgramming;

/**
 * 01背包问题解法
 * <p>
 * 问题描述：
 * 有 n 件物品和一个最多能背重量为 w 的背包。第i件物品的重量是 weight[i]，得到的价值是 value[i] 。
 * 每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。
 * <p>
 * 解题思路：
 * 使用动态规划解决01背包问题
 * 1. 状态定义：dp[i][j] 表示从前 i 个物品中选择，且背包容量为 j 时能获得的最大价值
 * 2. 状态转移方程：
 * - 如果当前物品重量超过背包容量：dp[i][j] = dp[i-1][j] （不能放入）
 * - 否则：dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]) （不放 vs 放入）
 * 3. 初始化：第一行表示只考虑第一个物品，在容量允许的情况下放入第一个物品
 * 4. 遍历顺序：外层遍历物品，内层遍历背包容量
 */
public class Day20251113 {
    /**
     * 01背包问题主函数
     *
     * @param weight 物品重量数组
     * @param value  物品价值数组
     * @param w      背包最大承重
     * @return 能获得的最大价值
     */
    public int zeroOneBag(int[] weight, int[] value, int w) {
        int n = weight.length;
        // dp[i][j] 表示从前 i 个物品中选择，且背包容量为 j 时能获得的最大价值
        int[][] dp = new int[n][w + 1];

        // 初始化：处理第一个物品（索引为0）
        // 当背包容量大于等于第一个物品重量时，可以放入第一个物品，获得其价值
        for (int i = weight[0]; i <= w; i++) {
            dp[0][i] = value[0];
        }

        // 从第二个物品开始遍历（索引从1开始）
        for (int i = 1; i < n; i++) {
            // 遍历各种背包容量情况（从0到最大容量w）
            for (int j = 0; j <= w; j++) {
                // 如果当前背包容量小于当前物品重量，则无法放入该物品
                // 所以最大价值等于不放入该物品时的最大价值（上一行同列的值）
                if (j < weight[i]) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    // 如果当前背包容量大于等于当前物品重量，则可以选择是否放入
                    // 取两种情况的最大值：
                    // 1. 不放入当前物品：dp[i-1][j]（上一行同列的值）
                    // 2. 放入当前物品：dp[i-1][j-weight[i]] + value[i]（放入后的价值）
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
                }
            }
        }
        // 返回考虑所有物品且背包容量为w时能获得的最大价值
        return dp[n - 1][w];
    }
}