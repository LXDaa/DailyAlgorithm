package DynamicProgramming;

/**
 * <a href="https://leetcode.cn/problems/unique-paths/description/">62.不同路径</a>
 * <p>
 * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 "Start" ）。
 * <p>
 * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 "Finish" ）。
 * <p>
 * 问总共有多少条不同的路径？
 * <p>
 * 解题思路:
 * 使用动态规划方法解决该问题。
 * 1. 状态定义: dp[i][j] 表示从起点(0,0)到点(i,j)的不同路径数目
 * 2. 状态转移方程: dp[i][j] = dp[i-1][j] + dp[i][j-1]
 *    (当前点的路径数 = 上方点的路径数 + 左方点的路径数)
 * 3. 初始条件: 第一行和第一列的所有点路径数都为1
 *    (因为只能一直向右或一直向下到达这些点)
 * 4. 最终结果: dp[m-1][n-1] 即为所求的不同路径总数
 * <p>
 * 时间复杂度: O(m*n)
 * 空间复杂度: O(m*n)
 */
public class Day20251107 {
    public int uniquePaths(int m, int n) {
        // 创建二维数组dp，其中dp[i][j]表示从起点到位置(i,j)的不同路径数
        int[][] dp = new int[m][n];
        
        // 初始化第一列：由于只能向下走，所以第一列每个位置只有一种路径
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        
        // 初始化第一行：由于只能向右走，所以第一行每个位置只有一种路径
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }
        
        // 填充dp表：每个位置的路径数等于其上方和左方位置路径数之和
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        
        // 返回右下角位置的路径数，即为不同路径的总数
        return dp[m - 1][n - 1];
    }
}