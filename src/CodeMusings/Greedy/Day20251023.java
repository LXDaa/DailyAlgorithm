package CodeMusings.Greedy;

/**
 * <a href="https://leetcode.cn/problems/gas-station/description/">134. 加油站</a>
 * <p>
 * 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
 * <p>
 * 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
 * <p>
 * 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。
 * <p>
 * 解题思路：
 * <p>
 * 使用贪心算法解决该问题。核心思想是：
 * <p>
 * 1. 如果总油量小于总消耗量，那么无论如何都无法绕行一圈，直接返回-1
 * <p>
 * 2. 如果总油量大于等于总消耗量，那么一定存在解
 * <p>
 * 3. 从起点开始遍历，记录当前油量，如果在某个位置油量变为负数，说明从之前的起点无法到达该位置，因此需要将起点设为下一个位置
 * <p>
 * 4. 局部最优：从当前起点开始，尽可能走更远的距离
 * <p>
 * 5. 全局最优：找到一个起点，能够走完所有加油站
 */
public class Day20251023 {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        // 加油站数量
        int n = gas.length;
        // 当前路径累计油量差值（用于寻找合适的起点）
        int sum = 0;
        // 所有站点总油量差值（判断是否能完成一圈）
        int total = 0;
        // 记录可能的起始位置
        int start = 0;

        for (int i = 0; i < n; i++) {
            // 累计经过第i个加油站后的净油量变化
            // gas[i] - cost[i] 表示在第i个加油站加油后前往下一站的净收益
            sum += gas[i] - cost[i];
            total += gas[i] - cost[i];

            // 如果当前累计油量为负，说明从之前设定的起点start无法到达第i+1个加油站
            // 因此需要将起点重新设置为i+1，并重置当前累计油量
            if (sum < 0) {
                sum = 0;
                start = i + 1;
            }
        }

        // 如果总的油量差为负数，说明无论从哪一点出发都无法完成一圈
        // 否则返回找到的起始位置
        return total < 0 ? -1 : start;
    }
}