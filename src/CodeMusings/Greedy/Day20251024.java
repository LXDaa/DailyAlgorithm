package CodeMusings.Greedy;

/**
 * <a href="https://leetcode.cn/problems/candy/description/">135. 分发糖果</a>
 * <p>
 * n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。
 * <p>
 * 你需要按照以下要求，给这些孩子分发糖果：
 * <p>
 * 每个孩子至少分配到 1 个糖果。
 * <p>
 * 相邻两个孩子中，评分更高的那个会获得更多的糖果。
 * <p>
 * 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。
 * <p>
 * 解题思路：
 * 这是一个典型的贪心算法问题。要满足所有条件并使得糖果总数最少，我们需要：
 * <p>
 * 方法一：两次遍历法
 * 1. 从左到右扫描一次，确保每个评分比左邻居高的孩子获得比左邻居更多的糖果（左规则）
 * 2. 从右到左扫描一次，确保每个评分比右邻居高的孩子获得比右邻居更多的糖果（右规则）
 * 3. 对于每个孩子，取两次扫描结果的最大值，以满足两个方向的约束
 * <p>
 * 方法二：常数空间遍历法
 * 通过观察规律，我们可以在一次遍历中完成计算，只需要记录递增序列长度和递减序列长度
 * <p>
 * 算法复杂度：
 * 方法一：时间复杂度 O(n)，空间复杂度 O(n)
 * 方法二：时间复杂度 O(n)，空间复杂度 O(1)
 * <p>
 */
public class Day20251024 {

    /**
     * 方法一：两次遍历法
     * <p>
     * 解题思路：
     * 1. 初始化每个孩子至少有1颗糖果
     * 2. 从左往右遍历，如果右边孩子评分高于左边，则右边孩子糖果数 = 左边孩子糖果数 + 1
     * 3. 从右往左遍历，如果左边孩子评分高于右边，且左边孩子当前糖果数不大于右边，则左边孩子糖果数 = 右边孩子糖果数 + 1
     * 4. 累加所有糖果数
     */
    static class Solution1 {
        public int candy(int[] ratings) {
            int n = ratings.length;

            // 记录每个孩子分到的糖果数，初始化为0
            int[] candyArr = new int[n];

            // 第一个孩子至少分到1颗糖果
            candyArr[0] = 1;

            // 从左往右遍历，处理右侧规则：
            // 如果当前孩子评分高于左侧孩子，则其糖果数应比左侧孩子多1颗
            // 否则只需保证至少有1颗糖果
            for (int i = 1; i < n; i++) {
                candyArr[i] = (ratings[i - 1] < ratings[i]) ? candyArr[i - 1] + 1 : 1;
            }

            // 从右往左遍历，处理左侧规则：
            // 如果当前孩子评分高于右侧孩子，需要保证其糖果数大于右侧孩子
            // 所以取当前值和右侧孩子糖果数+1 的较大值
            for (int i = n - 2; i >= 0; i--) {
                if (ratings[i] > ratings[i + 1]) {
                    candyArr[i] = Math.max(candyArr[i], candyArr[i + 1] + 1);
                }
            }

            // 统计总共需要的糖果数量
            int res = 0;
            for (int num : candyArr) {
                res += num;
            }
            return res;
        }
    }

    /**
     * 方法二：常数空间遍历法
     * <p>
     * 解题思路：
     * 通过观察可以发现，糖果分配的序列可以看作是递增序列和递减序列的组合。
     * 我们维护以下几个变量：
     * - inc: 当前递增序列的长度
     * - dec: 当前递减序列的长度
     * - pre: 前一个孩子分到的糖果数
     * - ret: 总共分到的糖果数
     * <p>
     * 处理逻辑：
     * 1. 如果当前孩子评分大于等于前一个孩子：
     *    - 重置递减序列长度为0
     *    - 如果评分相等，则当前孩子分到1颗糖果；否则分到pre+1颗糖果
     *    - 更新递增序列长度和总糖果数
     * 2. 如果当前孩子评分小于前一个孩子：
     *    - 递减序列长度加1
     *    - 如果递减序列长度等于递增序列长度，需要将递减序列延长1位以避免冲突
     *    - 更新总糖果数
     */
    static class Solution2 {
        public int candy(int[] ratings) {
            int n = ratings.length;
            // 第一个孩子至少分到1颗糖果，所以初始值为1
            int ret = 1;
            // inc表示递增序列长度，dec表示递减序列长度，pre表示前一个孩子分到的糖果数
            int inc = 1, dec = 0, pre = 1;
            
            for (int i = 1; i < n; i++) {
                if (ratings[i] >= ratings[i - 1]) {
                    // 当前孩子评分不低于前一个孩子
                    dec = 0; // 重置递减序列长度
                    
                    // 如果评分相同，当前孩子分到1颗糖果；否则分到pre+1颗糖果
                    pre = ratings[i] == ratings[i - 1] ? 1 : pre + 1;
                    
                    // 累加当前孩子分到的糖果数
                    ret += pre;
                    
                    // 更新递增序列长度
                    inc = pre;
                } else {
                    // 当前孩子评分低于前一个孩子，形成递减序列
                    dec++;
                    
                    // 当递减序列长度等于递增序列长度时，
                    // 需要将递减序列延长一位以避免冲突
                    if (dec == inc) {
                        dec++;
                    }
                    
                    // 累加递减序列带来的糖果增量
                    ret += dec;
                    
                    // 重置前一个孩子分到的糖果数
                    pre = 1;
                }
            }
            return ret;
        }
    }
}