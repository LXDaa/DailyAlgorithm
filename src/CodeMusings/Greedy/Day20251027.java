package CodeMusings.Greedy;

import java.util.Arrays;
import java.util.LinkedList;

public class Day20251027 {
    /**
     * <a href="https://leetcode.cn/problems/lemonade-change/description/">860.柠檬水找零</a>
     * <p>
     * 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。
     * <p>
     * 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。
     * <p>
     * 注意，一开始你手头没有任何零钱。
     * <p>
     * 给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。
     */
     
    // 解题思路：
    // 这是一道典型的贪心算法问题。我们需要根据顾客支付的钱币面值来进行找零。
    // 策略如下：
    // 1. 当收到5美元时，直接收下，无需找零
    // 2. 当收到10美元时，需要找零5美元，检查是否有5美元纸币
    // 3. 当收到20美元时，有两种找零方式：
    //    - 优先使用一张10美元+一张5美元找零（15美元）
    //    - 备选方案：使用三张5美元找零（15美元）
    // 贪心策略体现在处理20美元的时候，优先使用10美元纸币，因为10美元只能用于20美元的找零，
    // 而5美元用途更广，可以用于10美元和20美元的找零
    
    public boolean lemonadeChange(int[] bills) {
        // 记录手中拥有的5美元和10美元纸币数量
        int five = 0, ten = 0;
        
        // 按顺序处理每一位顾客的付款
        for (int bill : bills) {
            // 如果顾客支付5美元
            if (bill == 5) {
                // 直接收下，无需找零
                five++;
            } 
            // 如果顾客支付10美元
            else if (bill == 10) {
                // 需要找零5美元，检查是否有足够的5美元纸币
                if (five == 0) {
                    // 没有5美元纸币，无法找零，返回false
                    return false;
                }
                // 找零成功，减少一张5美元纸币，增加一张10美元纸币
                five--;
                ten++;
            } 
            // 如果顾客支付20美元（只剩下这种情况）
            else {
                // 贪心策略：优先使用一张10美元+一张5美元找零
                if (five > 0 && ten > 0) {
                    five--;
                    ten--;
                } 
                // 备选方案：使用三张5美元找零
                else if (five >= 3) {
                    five -= 3;
                } 
                // 两种方案都无法实施，无法找零
                else {
                    return false;
                }
            }
        }
        // 所有顾客都能成功找零
        return true;
    }

    /**
     *
     * <a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406. 根据身高重建队列</a>
     * <p>
     * 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
     * <p>
     * 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
     * <p>
     */
     
    // 解题思路：
    // 这是一个经典的贪心算法问题，解决的关键在于确定插入顺序。
    // 策略如下：
    // 1. 先对所有人按身高从高到低排序，如果身高相同则按k值从小到大排序
    // 2. 按照排序后的顺序依次将每个人插入到结果队列中
    // 3. 插入位置由该人的k值决定，即插入到当前队列的第k个位置
    // 
    // 为什么这样做是对的？
    // - 对于身高较高的人，他们看不到身高较矮的人，所以他们的k值仅由身高>=他们的人决定
    // - 当我们按身高从高到低处理时，每次插入的人都能看到之前已插入的所有人
    // - 因此，当他插入到第k个位置时，正好前面有k个身高>=他的人，满足条件
    
    public int[][] reconstructQueue(int[][] people) {
        // 排序规则：
        // 1. 按身高降序排列（身高高的在前）
        // 2. 身高相同时按k值升序排列（k小的在前）
        Arrays.sort(people, (a, b) -> a[0] != b[0] ? b[0] - a[0] : a[1] - b[1]);
        
        // 使用LinkedList便于在任意位置插入元素
        LinkedList<int[]> que = new LinkedList<>();

        // 遍历排序后的数组，按顺序插入每个人到正确位置
        for (int[] p : people) {
            // 将当前人插入到队列中其k值（p[1]）指定的位置
            // 因为前面已经按身高降序排列，所以当前人插入时，队列中所有人都比他高或等高
            // 所以只需要保证前面有k个比他高或等高的人即可
            que.add(p[1],  p);
        }

        // 将LinkedList转换为二维数组返回
        return que.toArray(new  int[people.length][]);

    }
}