package CodeMusings.DynamicProgramming;

/**
 * <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309.最佳买卖股票时机含冷冻期</a>
 * <p>
 * 给定一个整数数组prices,其中第  prices[i] 表示第 i 天的股票价格 。
 * <p>
 * 设计一个算法计算出最大利润。在满足以下约束条件下,你可以尽可能地完成更多的交易(多次买卖一支股票):
 * <p>
 * 卖出股票后,你无法在第二天买入股票 (即冷冻期为 1 天)。
 * 注意:你不能同时参与多笔交易(你必须在再次购买前出售掉之前的股票)。
 * <p>
 * 解题思路:
 * 1. 这是一个带冷冻期的股票买卖问题,关键在于正确定义状态
 * 2. 使用动态规划,将每一天的状态细分为4种情况
 * 3. 状态定义:
 * dp[i][0]: 第i天持有股票的最大利润
 * dp[i][1]: 第i天不持有股票,且处于冷冻期之外(保持卖出状态)的最大利润
 * dp[i][2]: 第i天不持有股票,且今天刚卖出(明天进入冷冻期)的最大利润
 * dp[i][3]: 第i天处于冷冻期的最大利润
 * 4. 状态转移方程:
 * dp[i][0] = max(dp[i-1][0], dp[i-1][3] - prices[i], dp[i-1][1] - prices[i])
 * (保持持有 或 冷冻期后买入 或 卖出状态买入)
 * dp[i][1] = max(dp[i-1][1], dp[i-1][3])
 * (保持卖出状态 或 冷冻期结束)
 * dp[i][2] = dp[i-1][0] + prices[i]
 * (今天卖出股票)
 * dp[i][3] = dp[i-1][2]
 * (前一天卖出,今天进入冷冻期)
 * 5. 初始状态:
 * dp[0][0] = -prices[0] (第一天买入)
 * dp[0][1] = 0 (第一天不操作)
 * dp[0][2] = 0 (第一天不能卖出)
 * dp[0][3] = 0 (第一天不可能处于冷冻期)
 * 6. 最终答案: max(dp[n-1][1], dp[n-1][2], dp[n-1][3])
 * (最后一天不持有股票的所有状态中的最大值)
 *
 * @author lxd
 **/
public class Day20251210 {
    /**
     * 计算最大利润
     *
     * @param prices 股票价格数组,prices[i]表示第i天的股票价格
     * @return 最大利润
     */
    public int maxProfit(int[] prices) {
        int n = prices.length;

        /*
         * dp[i][j]表示第i天处于状态j时的最大利润
         * j=0: 持有股票
         * j=1: 不持有股票,处于卖出状态(非冷冻期)
         * j=2: 不持有股票,今天刚卖出(明天进入冷冻期)
         * j=3: 处于冷冻期
         */
        int[][] dp = new int[n][4];

        /*
         * 初始化第0天的状态
         */

        /* 第0天买入股票,利润为-prices[0] */
        dp[0][0] = -prices[0];

        /* 第0天不操作,利润为0 */
        dp[0][1] = 0;

        /* 第0天无法卖出,利润为0 */
        dp[0][2] = 0;

        /* 第0天不可能处于冷冻期,利润为0 */
        dp[0][3] = 0;

        /*
         * 从第1天开始进行状态转移
         */
        for (int i = 1; i < n; i++) {
            /*
             * 状态0: 持有股票
             * 可能来源:
             * 1. 前一天就持有股票,今天继续持有: dp[i-1][0]
             * 2. 前一天是冷冻期,今天买入: dp[i-1][3] - prices[i]
             * 3. 前一天是卖出状态,今天买入: dp[i-1][1] - prices[i]
             */
            dp[i][0] = Math.max(dp[i - 1][0], Math.max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]));

            /*
             * 状态1: 不持有股票,处于卖出状态(非冷冻期)
             * 可能来源:
             * 1. 前一天就是卖出状态,今天保持: dp[i-1][1]
             * 2. 前一天是冷冻期,今天结束冷冻: dp[i-1][3]
             */
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);

            /*
             * 状态2: 今天刚卖出股票
             * 来源: 前一天持有股票,今天卖出: dp[i-1][0] + prices[i]
             */
            dp[i][2] = dp[i - 1][0] + prices[i];

            /*
             * 状态3: 处于冷冻期
             * 来源: 前一天卖出股票,今天进入冷冻期: dp[i-1][2]
             */
            dp[i][3] = dp[i - 1][2];
        }

        /*
         * 最后一天不持有股票的所有状态中取最大值
         * 包括:卖出状态、今天刚卖出、冷冻期
         */
        return Math.max(dp[n - 1][1], Math.max(dp[n - 1][2], dp[n - 1][3]));

    }
}
