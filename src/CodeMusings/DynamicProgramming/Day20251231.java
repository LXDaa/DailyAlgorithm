package CodeMusings.DynamicProgramming;

/**
 * 516. 最长回文子序列
 * <p>
 * 问题描述:
 * 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。
 * 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
 * <p>
 * 解题思路:
 * 使用动态规划解决此问题。
 * <p>
 * 状态定义:
 * dp[i][j] 表示字符串 s 的子串 s[i...j] 中最长回文子序列的长度。
 * <p>
 * 状态转移方程:
 * 1. 当 s[i] == s[j] 时，两端字符相同，可以构成回文，所以 dp[i][j] = dp[i+1][j-1] + 2
 * 2. 当 s[i] != s[j] 时，两端字符不同，需要选择其中较长的回文子序列，
 * 所以 dp[i][j] = max(dp[i][j-1], dp[i+1][j])
 * <p>
 * 初始状态:
 * 当 i == j 时，单个字符的最长回文子序列长度为 1，即 dp[i][i] = 1
 * <p>
 * 最终答案:
 * dp[0][n-1] 即为整个字符串的最长回文子序列长度
 *
 * @author lxd
 **/
public class Day20251231 {
    /**
     * 计算字符串中最长回文子序列的长度
     *
     * @param s 输入字符串
     * @return 最长回文子序列的长度
     */
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        // 创建二维DP数组，dp[i][j]表示s[i...j]中最长回文子序列的长度
        int[][] dp = new int[n][n];

        // 从下往上遍历，确保子问题已解决
        for (int i = n - 1; i >= 0; i--) {
            // 单个字符的最长回文子序列长度为1
            dp[i][i] = 1;

            // 从i+1开始向右遍历
            for (int j = i + 1; j < n; j++) {
                // 如果两端字符相同，可以在内部回文基础上加上这两个字符
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    // 如果两端字符不同，取左右子串中较长的回文子序列
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);
                }
            }
        }

        // 返回整个字符串的最长回文子序列长度
        return dp[0][n - 1];
    }
}