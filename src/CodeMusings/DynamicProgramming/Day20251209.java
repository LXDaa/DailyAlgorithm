package CodeMusings.DynamicProgramming;

/**
 * <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">188.买卖股票的最佳时机IV</a>
 * 给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。
 * <p>
 * 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。
 * <p>
 * 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
 * <p>
 * 解题思路：
 * 本题是股票买卖问题的通用版本，可以进行最多k笔交易。
 * 核心思想是使用动态规划，将每次交易拆分为买入和卖出两个状态。
 * <p>
 * 状态定义：
 * dp[i][j] 表示在第i天，处于第j个状态时的最大利润
 * j的取值范围是 [0, 2*k]，共 2*k+1 个状态：
 * - j=0: 未进行任何操作
 * - j=1: 第1次买入后持有股票
 * - j=2: 第1次卖出后不持有股票
 * - j=3: 第2次买入后持有股票
 * - j=4: 第2次卖出后不持有股票
 * - ...
 * - j=2k-1: 第k次买入后持有股票
 * - j=2k: 第k次卖出后不持有股票
 * <p>
 * 状态转移方程：
 * 对于奇数状态j（买入状态）：
 * dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] - prices[i])
 * 含义：第i天第j状态 = max(前一天已经是第j状态, 前一天是第j-1状态今天买入)
 * 对于偶数状态j（卖出状态，j>0）：
 * dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i])
 * 含义：第i天第j状态 = max(前一天已经是第j状态, 前一天是第j-1状态今天卖出)
 * <p>
 * 初始状态：
 * dp[0][0] = 0（第0天未操作，利润为0）
 * dp[0][奇数] = -prices[0]（第0天买入股票，利润为负的股价）
 * dp[0][偶数且>0] = 0（第0天不可能完成卖出操作，默认为0）
 * <p>
 * 最终答案：
 * dp[len-1][2k] 表示完成k次交易后的最大利润
 *
 * @author lxd
 **/
public class Day20251209 {
    public int maxProfit(int k, int[] prices) {
        int len = prices.length;

        /*
         * 定义dp数组
         * dp[i][j]: 第i天处于第j个状态时的最大利润
         * 一共有2k+1个状态（0到2k）
         */
        int[][] dp = new int[len][2 * k + 1];

        /*
         * 初始化第0天的状态
         * 遍历所有奇数状态（买入状态），初始化为-prices[0]
         * 因为第0天买入股票，利润为负的当天股价
         */
        for (int i = 1; i < 2 * k; i += 2) {
            dp[0][i] = -prices[0];
        }

        /*
         * 状态转移过程
         * 从第1天开始遍历到最后一天
         */
        for (int i = 1; i < len; i++) {
            /*
             * 遍历所有交易次数
             * j从0开始，每次+2，对应每一次完整的交易周期
             * 每次循环处理一对买入和卖出状态
             */
            for (int j = 0; j < 2 * k; j += 2) {
                /*
                 * 计算买入状态 dp[i][j+1]
                 * 两种选择取最大值：
                 * 1. 前一天已经买入：dp[i-1][j+1]
                 * 2. 今天买入：dp[i-1][j] - prices[i]
                 */
                dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);

                /*
                 * 计算卖出状态 dp[i][j+2]
                 * 两种选择取最大值：
                 * 1. 前一天已经卖出：dp[i-1][j+2]
                 * 2. 今天卖出：dp[i-1][j+1] + prices[i]
                 */
                dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }

        /*
         * 返回最后一天完成k次交易后的最大利润
         * dp[len-1][2k]表示第len-1天，完成k次买卖后的状态
         */
        return dp[len - 1][2 * k];
    }
}
