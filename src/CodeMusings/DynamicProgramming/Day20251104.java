package CodeMusings.DynamicProgramming;

/**
 * <a href="https://leetcode.cn/problems/fibonacci-number/description/">509. 斐波那契数</a>
 * <p>
 * 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
 * <p>
 * F(0) = 0，F(1) = 1
 * <p>
 * F(n) = F(n - 1) + F(n - 2)，其中 n > 1
 * <p>
 * 给定 n ，请计算 F(n) 。
 * <p>
 * 解题思路:
 * 1. 斐波那契数列是最经典的动态规划问题之一
 * 2. 递归解法存在大量重复计算，时间复杂度为O(2^n)
 * 3. 使用动态规划自底向上计算，避免重复计算
 * 4. 采用滚动数组优化，只保存必要的前两个状态值，节省空间
 */
public class Day20251104 {
    /**
     * 计算斐波那契数 F(n)
     *
     * @param n 输入的非负整数
     * @return 返回斐波那契数 F(n)
     * <p>
     * 算法思路:
     * 使用三个变量滚动记录斐波那契数列的连续三项:
     * a = F(i-2), b = F(i-1), c = F(i)
     * 每次迭代更新这三个变量的值，最终得到F(n)
     * <p>
     * 算法复杂度分析:
     * 时间复杂度: O(n) - 需要从2迭代到n
     * 空间复杂度: O(1) - 只使用了常数级别的额外空间
     */
    public int fib(int n) {
        // 处理基础情况: F(0)=0, F(1)=1
        if (n < 2) {
            return n;
        }

        // 初始化前两项的值
        // a = F(0) = 0
        // b = F(1) = 1
        // c 用于计算 F(2) = F(0) + F(1) = 0 + 1 = 1
        int a = 0, b = 1, c = 0;

        // 从第2项开始计算到第n项
        for (int i = 2; i <= n; i++) {
            // 计算当前项: F(i) = F(i-1) + F(i-2)
            c = a + b;
            // 滚动更新前两项的值
            // 原来的 F(i-1) 成为下一轮的 F(i-2)
            a = b;
            // 原来的 F(i) 成为下一轮的 F(i-1)
            b = c;
        }
        return c;
    }
}