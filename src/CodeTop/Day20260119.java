package CodeTop;

/**
 * <a href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和</a>
 * 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
 * <p>
 * 子数组是数组中的一个连续部分。
 * <p>
 * 解题思路：
 * 使用贪心算法思想解决最大子数组和问题。
 * 核心思想是：如果当前累加和为正，则继续累加当前元素；如果当前累加和为负，则从当前元素重新开始计算子数组和。
 * 因为负数只会拉低后续子数组的和，所以应该舍弃之前的累加结果。
 * <p>
 * 算法步骤：
 * 1. 初始化结果ans为nums[0]，累加和sum为0
 * 2. 遍历数组中的每个元素num：
 * - 如果当前sum > 0，说明之前的累积对当前子数组有益，将num加入到sum中
 * - 如果当前sum <= 0，说明之前的累积对当前子数组无益，重新以num作为新子数组的起点
 * - 更新ans为ans和sum的最大值
 * 3. 返回最终的最大子数组和ans
 * <p>
 * 示例演示：
 * 对于数组[-2,1,-3,4,-1,2,1,-5,4]
 * - 第1步：sum=0, num=-2, sum<=0, sum=-2, ans=max(-2,-2)=-2
 * - 第2步：sum=-2, num=1, sum<=0, sum=1, ans=max(-2,1)=1
 * - 第3步：sum=1, num=-3, sum>0, sum=1+(-3)=-2, ans=max(1,-2)=1
 * - 第4步：sum=-2, num=4, sum<=0, sum=4, ans=max(1,4)=4
 * - 第5步：sum=4, num=-1, sum>0, sum=4+(-1)=3, ans=max(4,3)=4
 * - ...以此类推
 * 最终得到最大子数组和为6，对应子数组[4,-1,2,1]
 * <p>
 * 时间复杂度：O(n)，其中n是数组长度，只需遍历一次数组
 * 空间复杂度：O(1)，只使用了常数级别的额外空间
 *
 * @author lxd
 **/
public class Day20260119 {
    public int maxSubArray(int[] nums) {
        // 初始化结果为数组第一个元素，确保至少有一个元素被考虑
        int ans = nums[0];
        // 当前子数组的累加和
        int sum = 0;

        // 遍历数组中的每个元素
        for (int num : nums) {
            // 如果当前累加和大于0，说明对后续子数组和有正面贡献，继续累加
            if (sum > 0) {
                sum += num;
            } else {
                // 如果当前累加和小于等于0，说明之前的累积对后续无益，重新以当前元素开始
                sum = num;
            }
            // 更新全局最大值
            ans = Math.max(ans, sum);
        }
        return ans;
    }
}
